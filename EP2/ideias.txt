	Um ciclista a 30km/h sempre tende a ficar na pista mais interna
possível (onde a mais interna é a coluna com menor indice em uma
linha da matriz da pista).

	Entenda "ir em frente" como ter uma vMax >= v, ou seja, não
estar bloqueado por um ciclista à sua frente.
	Um ciclista a 60km/h ou 90km/h sempre prioriza ir em frente
sobre mudar de pista. Sendo assim, DEPOIS de ir em frente, tal
ciclista tenta ir a uma pista mais interna, se possível.
	Caso ele não seja capaz de ir em frente, o ciclista se move
a uma pista adjacente mais externa e segue em sua vMax (até a
próxima checagem, claro).

	A variável na struct ciclista que indica se eles estão
quebrados deve salvar a volta em que um ciclista quebrou, ou
-1 caso ele não tenha quebrado.

	Para impedir que dois ciclistas tentem mudar para uma posiçao
da pista (matriz) ao mesmo tempo e potencialmente sobreescrever
um ao outro, podemos fazer uma matriz de semaforos, do mesmo
tamanho da matriz da pista, isso é, um semaforo pra cada posiçao
da pista, assim os ciclistas podem disputar a posiçao sem forçar
todos os outros a pararem a execuçao antes de comparar (que
aconteceria no caso de termos um unico semaforo para a comparaçao)

	TESTES:
		- Sempre q a função andaFrente devolve 1, a posição de
		origem e destino do ciclista apresentam os valores
		corretos (-1 e c.id, respectivamente). Estaria o problema
		na mudança de faixa? N, parece estar funcionando ok.

		- O problema deve ser quando o ciclista tenta avançar e n
		consegue. Quando, em outra iteração ele for andar, ele vai
		"pular" uma posição, e acabar mantendo seu id duas posições
		atrás na pista.